/*******************************************************************************
 This file is part of FeCl.
 
 Copyright (c) 2015, Etienne Pierre-Doray, INRS
 Copyright (c) 2015, Leszek Szczecinski, INRS
 All rights reserved.
 
 FeCl is free software: you can redistribute it and/or modify
 it under the terms of the Lesser General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 FeCl is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the Lesser General Public License
 along with FeCl.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

#include "Ldpc.h"
#include "detail/BpDecoder/BpDecoder.h"

using namespace fec;

BOOST_CLASS_EXPORT_IMPLEMENT(Ldpc);


Ldpc::Ldpc(const detail::Ldpc::Structure& structure,  int workGroupSize) :
Codec(std::unique_ptr<detail::Ldpc::Structure>(new detail::Ldpc::Structure(structure)), workGroupSize)
{
}

Ldpc::Ldpc(const EncoderOptions& encoder, const DecoderOptions& decoder, int workGroupSize) :
Codec(std::unique_ptr<detail::Ldpc::Structure>(new detail::Ldpc::Structure(encoder, decoder)), workGroupSize)
{
}

Ldpc::Ldpc(const EncoderOptions& encoder, int workGroupSize) :
Codec(std::unique_ptr<detail::Ldpc::Structure>(new detail::Ldpc::Structure(encoder)), workGroupSize)
{
}

const char * Ldpc::get_key() const {
  return boost::serialization::type_info_implementation<Ldpc>::type::get_const_instance().get_key();
}

void Ldpc::soDecodeBlocks(detail::Codec::const_iterator<double> first, detail::Codec::const_iterator<double> last, detail::Codec::iterator<double> output) const
{
  auto worker = detail::BpDecoder::create(structure());
  worker->soDecodeBlocks(first, last, output);
}

void Ldpc::decodeBlocks(detail::Codec::const_iterator<double> first, detail::Codec::const_iterator<double> last, detail::Codec::iterator<BitField<size_t>> output) const
{
  auto worker = detail::BpDecoder::create(structure());
  worker->decodeBlocks(first.at(detail::Codec::Parity), last.at(detail::Codec::Parity), output.at(detail::Codec::Msg));
}

/**
 *  Create a random ldpc matrix using gallager construction method.
 *  This matrix describes a regular ldpc code with n parity.
 *  The tanner graph associated with this matrix will have wc branches
 *  connected to every check nodes and wr branches connected to every bit nodes.
 *  A matrix with n collumn is generated by inserting wr elements in each row.
 *  The first row will contain 1s at the first wr positions. The second row
 *  will contains 1s at the wr next positions. This continues until all collumns
 *  contain non-zero element. This is repeated wc times, ensuring that there is
 *  exactly wc non-zero elements in each column and wr non-zero elements in each row.
 *  The columns are the randomly permuted. The generated matrix will have at least
 *  n/wr linearly dependent rows.
 *  \param  n Number of parity bits (column) in the Ldpc code using the generated matrix
 *  \param  wc Number of branch connected to every check nodes.
 *  \param  wr Number of branch connected to every bit nodes
 */
SparseBitMatrix Ldpc::Gallager::matrix(size_t n, size_t wc, size_t wr, uint64_t seed)
{
  SparseBitMatrix H(n/wr * wc, n, wr);
  
  size_t elem = 0;
  auto row = H.begin();
  for (size_t i = 0; i < n/wr; i++) {
    for (size_t j = 0; j < wr; j++) {
      for (size_t k = 0; k < H.rows(); k+=n/wr) {
        row[k].set(elem);
      }
      elem++;
    }
    ++row;
  }
  
  std::minstd_rand0 generator((int)seed);
  for (size_t j = 0; j < H.cols(); j++) {
    std::uniform_int_distribution<int> distribution(int(j),int(H.cols()-1));
    for (size_t i = n/wr; i < H.rows(); i+=n/wr) {
      H.swapCols(j, distribution(generator), {i, i+n/wr});
    }
  }
  
  return H;
}

