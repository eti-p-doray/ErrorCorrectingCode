/*******************************************************************************
 Copyright (c) 2015, Etienne Pierre-Doray, INRS
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 
 * Redistributions of source code must retain the above copyright notice, this
 list of conditions and the following disclaimer.
 
 * Redistributions in binary form must reproduce the above copyright notice,
 this list of conditions and the following disclaimer in the documentation
 and/or other materials provided with the distribution.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 Definition of MapCodec class
 ******************************************************************************/

#include "Ldpc.h"
#include "BpDecoder/BpDecoder.h"

using namespace fec;

BOOST_CLASS_EXPORT_IMPLEMENT(Ldpc);
BOOST_CLASS_EXPORT_IMPLEMENT(Ldpc::Structure);

const char * Ldpc::get_key() const {
  return boost::serialization::type_info_implementation<Ldpc>::type::get_const_instance().get_key();
}

const char * Ldpc::Structure::get_key() const {
  return boost::serialization::type_info_implementation<Ldpc::Structure>::type::get_const_instance().get_key();
}

/**
 *  Ldpc constructor
 *  \param  codeStructure Codec structure used for encoding and decoding
 *  \param  workGroupSize Number of thread used for decoding
 */
Ldpc::Ldpc(const Ldpc::Structure& structure, int workGroupSize) :
structure_(structure),
Codec(&structure_, workGroupSize)
{
}

void Ldpc::soDecodeBlocks(InputIterator input, OutputIterator output, size_t n) const
{
  auto worker = BpDecoder::create(structure());
  worker->soDecodeBlocks(input, output, n);
}

void Ldpc::decodeBlocks(std::vector<LlrType>::const_iterator parity, std::vector<BitField<bool>>::iterator msg, size_t n) const
{
  /*auto worker = BpDecoder::create(structure());
  std::vector<LlrType> messageAPosteriori(n * systSize());
  worker->soDecodeBlocks(InputInfoIterator(&structure()).parity(parity), OutputInfoIterator(&structure()).syst(messageAPosteriori.begin()), n);
  
  for (size_t i = 0; i < structure().msgSize()*n; ++i) {
    msg[i] = (messageAPosteriori[i]+parity[i]) > 0;
  }*/
  
  auto worker = BpDecoder::create(structure());
  worker->decodeBlocks(parity, msg, n);
}

/**
 *  Create a random ldpc matrix using gallager construction method.
 *  This matrix describes a regular ldpc code with n parity.
 *  The tanner graph associated with this matrix will have wc branches
 *  connected to every check nodes and wr branches connected to every bit nodes.
 *  A matrix with n collumn is generated by inserting wr elements in each row.
 *  The first row will contain 1s at the first wr positions. The second row
 *  will contains 1s at the wr next positions. This continues until all collumns
 *  contain non-zero element. This is repeated wc times, ensuring that there is
 *  exactly wc non-zero elements in each column and wr non-zero elements in each row.
 *  The columns are the randomly permuted. The generated matrix will have at least
 *  n/wr linearly dependent rows.
 *  \param  n Number of parity bits (column) in the Ldpc code using the generated matrix
 *  \param  wc Number of branch connected to every check nodes.
 *  \param  wr Number of branch connected to every bit nodes
 */
SparseBitMatrix Ldpc::gallagerConstruction(size_t n, size_t wc, size_t wr)
{
  SparseBitMatrix H(n/wr * wc, n, wr);
  
  size_t elem = 0;
  auto row = H.begin();
  for (size_t i = 0; i < n/wr; i++) {
    for (size_t j = 0; j < wr; j++) {
      for (size_t k = 0; k < H.rows(); k+=n/wr) {
        row[k].set(elem);
      }
      elem++;
    }
    ++row;
  }
  
  uint64_t seed = 0;//std::chrono::system_clock::now().time_since_epoch().count();
  std::mt19937 generator((int)seed);
  for (size_t j = 0; j < H.cols(); j++) {
    std::uniform_int_distribution<int> distribution(int(j),int(H.cols()-1));
    for (size_t i = n/wr; i < H.rows(); i+=n/wr) {
      H.swapCols(j, distribution(generator), {i, i+n/wr});
    }
  }
  
  return H;
}

/**
 *  Ldpc code structure constructor.
 *  Constructs an ldpc code structure following a given ldpc matrix.
 *  A generator matrix is not needed to execute encoding.
 *  The matrix does not need to be triangular in shape or be invertible.
 *  The ldpc matrix will be transformed (if needed) to allow in-place encoding
 *  using its partial triangular form.
 *  \param  H Ldpc matrix describing the code
 *  \param  iterations  Maximum number of iteration in belief propagation decoding.
 *    The decoder can stop before the maximum number of iteration if the msg is consistent.
 *  \param  type  Decoder algorithm used
 */
Ldpc::Structure::Structure(const EncoderOptions& encoder, const DecoderOptions& decoder)
{
  msgSize_ = encoder.H_.cols()-encoder.H_.rows();
  paritySize_ = encoder.H_.cols();
  stateSize_ = encoder.H_.size();
  
  computeGeneratorMatrix(SparseBitMatrix(encoder.H_));
  
  systSize_ = msgSize_;
  decoderAlgorithm_ = decoder.algorithm_;
  iterations_ = decoder.iterations_;
}

/**
 *  Computes the syndrome given a sequence of parity bits.
 *  \param  parity  Input iterator pointing to the first element of the parity sequence.
 *  \param  syndrome[out] Output iterator pointing to the first
 *    element of the computed syndrome. The output needs to be allocated.
 */
void Ldpc::Structure::syndrome(std::vector<uint8_t>::const_iterator parity, std::vector<uint8_t>::iterator syndrome) const
{
  for (auto parityEq = checks().begin(); parityEq < checks().end(); ++parityEq, ++syndrome) {
    for (auto parityBit = parityEq->begin(); parityBit < parityEq->end(); ++parityBit) {
      *syndrome ^= parity[*parityBit];
    }
  }
}

/**
 *  Checks for the parity sequence consistency using its syndrome.
 *  \param  parity  Input iterator pointing to the first element of the parity sequence.
 *  \return True if the parity sequence is consistent. False otherwise.
 */
bool Ldpc::Structure::check(std::vector<BitField<uint8_t>>::const_iterator parity) const
{
  for (auto parityEq = checks().begin(); parityEq < checks().end(); ++parityEq) {
    bool syndrome;
    for (auto parityBit = parityEq->begin(); parityBit < parityEq->end(); ++parityBit) {
      syndrome ^= parity[*parityBit];
    }
    if (syndrome != 0) {
      return false;
    }
  }
  return true;
}

/**
 *  Encodes a sequence of msg bits using the transformed ldpc matrix.
 *  \param  msg Input iterator pointing to the first element of the msg bit sequence.
 *  \param  parity[out] Output iterator pointing to the first
 *    element of the computed parity sequence. The output needs to be allocated.
 */
void Ldpc::Structure::encode(std::vector<BitField<bool>>::const_iterator msg, std::vector<BitField<uint8_t>>::iterator parity) const
{
  std::copy(msg, msg + msgSize(), parity);
  std::fill(parity+msgSize(), parity+paritySize(), 0);
  parity += msgSize();
  auto parityIt = parity;
  for (auto row = DC_.begin(); row < DC_.end(); ++row, ++parityIt) {
    //auto msgIt = msg;
    for (auto elem = row->begin(); elem != row->end(); ++elem) {
      /*if (*elem) {
       *parityIt ^= *msgIt;
       }*/
      *parityIt ^= msg[*elem];
    }
  }
  for (auto row = B_.begin(); row < B_.end(); ++row, ++parityIt) {
    for (auto elem = row->begin(); elem < row->end(); ++elem) {
      *parityIt ^= parity[*elem];
    }
  }
  parity += DC_.rows();
  parityIt = parity;
  for (auto row = A_.begin(); row < A_.end(); ++row, ++parityIt) {
    for (auto elem = row->begin(); elem < row->end(); ++elem) {
      *parityIt ^= msg[*elem];
    }
  }
  parityIt = parity;
  for (auto row = T_.begin(); row < T_.end(); ++row, ++parityIt) {
    for (auto elem = row->begin()+1; elem < row->end(); ++elem) {
      parity[*elem] ^= *parityIt;
    }
  }
}

/**
 *  Transforms an ldpc matrix to allow in-place encoding.
 *  The matrix is transformed in a partial triangular shape.
 *  \param  H The original ldpc matrix
 */
void Ldpc::Structure::computeGeneratorMatrix(SparseBitMatrix&& H)
{
  std::vector<size_t> colSizes;
  size_t maxRow = H.rows();
  size_t tSize = 0;
  
  H.colSizes(colSizes);
  auto colSize = H.end()-1;
  for (size_t i = H.cols(); i > 0; --i) {
    for (; colSize >= H.begin() + maxRow; --colSize) {
      for (auto elem = colSize->begin(); elem < colSize->end(); ++elem) {
        colSizes[*elem]--;
      }
    }
    size_t minValue = -1;
    size_t minIdx = 0;
    for (int64_t j = i-1; j >= 0; j--) {
      if (colSizes[j] == 1) {
        minIdx = j;
        minValue = colSizes[j];
        break;
      }
      else if (colSizes[j] < minValue && colSizes[j] >= 1) {
        minIdx = j;
        minValue = colSizes[j];
      }
    }
    H.swapCols(minIdx, i-1);
    std::swap(colSizes[minIdx], colSizes[i-1]);
    size_t j = maxRow;
    for (auto row = H.begin(); row < H.begin()+j; ++row) {
      if (row->test(i-1)) {
        --j;
        std::swap(H[j], *row);
        --row;
      }
    }
    maxRow -= std::max(minValue, size_t(1));
    if (maxRow == 0) {
      tSize = H.cols()-i+1;
      break;
    }
  }
  
  for (size_t i = 0; i < tSize; ++i) {
    auto row = H.begin()+i;
    if (!row->test(i+H.cols()-tSize)) {
      ++row;
      for (; row < H.end(); ++row) {
        if (row->test(i+H.cols()-tSize)) {
          std::swap(H[i], *row);
          break;
        }
      }
    }
  }
  
  BitMatrix CDE = H({tSize, H.rows()}, {0, H.cols()});
  
  for (int64_t i = tSize; i >= 0; --i) {
    for (auto row = CDE.begin(); row < CDE.end(); ++row) {
      if (row->test(i+CDE.cols()-tSize)) {
        *row += H[i];
      }
    }
  }
  
  for (size_t i = 0; i < CDE.cols()-tSize-msgSize(); ++i) {
    uint8_t found = false;
    for (auto row = CDE.begin()+i; row < CDE.end(); ++row) {
      if (row->test(i+msgSize())) {
        std::swap(*row, CDE[i]);
        found = true;
        break;
      }
    }
    if (!found) {
      for (auto row = CDE.begin()+i; row < CDE.end(); ++row) {
        size_t k = row->first();
        if (k != -1) {
          H.swapCols(k, i+msgSize());
          CDE.swapCols(k, i+msgSize());
          std::swap(*row, CDE[i]);
          found = true;
          break;
        }
      }
    }
    if (!found) {
      H.moveCol(i+msgSize(), msgSize());
      CDE.moveCol(i+msgSize(), msgSize());
      ++msgSize_;
      --i;
      continue;
    }
    for (auto row = CDE.begin()+i+1; row < CDE.end(); ++row) {
      if (row->test(i+msgSize())) {
        *row += CDE[i];
      }
    }
  }
  
  for (int64_t i = CDE.rows()-1; i >= 0; --i) {
    for (auto row = CDE.begin()+i-1; row >= CDE.begin(); --row) {
      if (row->test(i+msgSize())) {
        *row += CDE[i];
      }
    }
  }
  
  H_ = H;
  DC_ = CDE({0, CDE.cols()-msgSize()-tSize}, {0, msgSize()});
  A_ = H_({0, tSize}, {0, msgSize()});
  B_ = H_({0, tSize}, {msgSize(), msgSize()+DC_.rows()});
  T_ = H_({0, tSize}, {H.cols()-tSize, H.cols()}).transpose();
}

